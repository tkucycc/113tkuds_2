// ===== ListNode 定義（含反序列化/序列化）=====
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }

    // 將字串如 "[1,2,3,4,5]" 轉為鏈結串列；"[]"/空白 → null
    static ListNode deserialize(String s) {
        if (s == null) return null;
        s = s.trim();
        if (s.isEmpty() || s.equals("[]")) return null;
        if (s.charAt(0) == '[') s = s.substring(1);
        if (s.charAt(s.length() - 1) == ']') s = s.substring(0, s.length() - 1);
        if (s.trim().isEmpty()) return null;

        String[] parts = s.split(",");
        ListNode dummy = new ListNode(0), cur = dummy;
        for (String p : parts) {
            p = p.trim();
            if (p.isEmpty()) continue;
            cur.next = new ListNode(Integer.parseInt(p));
            cur = cur.next;
        }
        return dummy.next;
    }

    // 方便本地印出檢查，如 [1,2,3]
    static String serialize(ListNode head) {
        StringBuilder sb = new StringBuilder("[");
        for (ListNode cur = head; cur != null; cur = cur.next) {
            if (cur != head) sb.append(',');
            sb.append(cur.val);
        }
        return sb.append(']').toString();
    }
}

// ===== 題目解答：雙指針一次掃描 =====
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode fast = dummy, slow = dummy;

        // 先讓 fast 領先 n+1 步，讓 slow 最後停在「目標前一個」
        for (int i = 0; i <= n; i++) {
            fast = fast.next;  // 題目保證 1<=n<=長度，不會 NPE
        }

        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        slow.next = slow.next.next;       // 刪除倒數第 n 個
        return dummy.next;
    }
}

/*
解題思路（雙指針 + dummy）：
1) 建立 dummy→head，避免刪頭節點時的特判。
2) 讓 fast 先走 n+1 步，使 fast 與 slow 相隔 n。
3) 之後同步前進直到 fast 為 null，此時 slow 停在「待刪節點的前一個」。
4) slow.next = slow.next.next 完成刪除，回傳 dummy.next。
時間 O(L)，空間 O(1)。
*/
