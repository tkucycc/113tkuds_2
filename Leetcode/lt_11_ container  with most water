class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int best = 0;

        while (l < r) {
            int h = Math.min(height[l], height[r]);
            best = Math.max(best, h * (r - l));

            // 關鍵：決定移哪一邊
            // 只有移動較短邊，才有可能讓 min(height[l], height[r]) 變大
            if (height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return best;
    }
}

/*
解題思路（雙指針）：
1) 面積 = (右索引 - 左索引) * min(左高, 右高)。
2) 固定一長一短時，移動「較長」的一邊只會縮小寬度，且高度下界仍受「較短」限制 → 面積不可能變大。
3) 因此每輪都移動「較短」的一邊，期望遇到更高的柱子，讓 min(height) 變大來補寬度的損失。
4) 左右指針相向而行掃完一次即得答案。
複雜度：時間 O(n)，空間 O(1)。
*/
